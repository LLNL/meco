# Work with LMAT count data
# Includes some ALDEx2 helpers

require(tidyverse)
require(magrittr)
require(glue)

#' Selects read counts for microbial taxa only
#'
#' @param lmat A tibble containing LMAT read counts, scores, and lineages.
#'             For example \code{lmat <- read_tsv("lmat_summary.txt")}
#'
keep_lmat_microbes <- function(lmat) {
  lmat %>%
    filter(!(kingdom %in% c("Metazoa", "Viridiplantae")) | is.na(kingdom)) %>%
    filter(!grepl("synthetic", species))
}

#' Sums read counts at the given rank
#'
#' @param lmat A tibble containing LMAT read counts, scores, and lineages
#' @param tax_rank genus, species, ... as bare words
#' @param keep_unknowns Keeps NA taxa and set taxon name to "UNKNOWN". Default, FALSE.
#'
#' For each sample, read counts for missing taxa that are seen in at least one
#' other sample are set to 0.
sum_lmat_at_rank <- function(lmat, tax_rank = genus, keep_unknowns = FALSE) {
  tax_rank <- enquo(tax_rank) # Hadley's dark magic, see vignette("programming")
  lmat_sum <- lmat %>%
    count(sample, !!tax_rank, wt = read_count) %>%
    rename(read_count = n) %>%
    complete(sample, !!tax_rank, fill = list(read_count = 0.0))
  if (keep_unknowns) {
    lmat_sum %<>%
      mutate(!!tax_rank := ifelse(is.na(!!tax_rank), "UNKNOWN", !!tax_rank))
  } else {
    lmat_sum %<>%
      filter(!is.na(!!tax_rank))
  }
  lmat_sum
}

#' Convert a tibble to a parameter list to pass to ALDEx2
#'
#' @param lmat tibble of read counts per taxon per sample
#' @param samp tibble with sample metadata
#' @param tax_rank genus, species, etc... as a bare word
#' @param keep_all add dummy uniform sample to keep all taxa
#' @param ... sample grouping variables as bare names
#' @param denom which taxa to use in calculating means
#'
#' It's probably better to convert lmat and sample data to a phyloseq object...
#'
#' Returns a list of parameters to pass to `aldex.clr`, and extra information
#' and extra information about the original tibble.
#'
#' `reads`: a data.frame with rows = taxa, columns = samples
#'
#'          ALDEx2 will mess up sample names with nonsyntactic characters
#'          Original sample names are stored in `$original_samplenames`
#'
#' `conds`: a character vector of sample group names
#'
#' `denom`: denom
#'
#'          \code{denom}: ALDEx2 will estimate the average relative abundance
#'          (geometric mean) per sample using features chosen by `denom`. By
#'          default `denom` computes the geometric mean using all features
#'          (taxa), but can select different features per condition. `denom =
#'          "iqlr"` will select features with interquartile clr variance within
#'          each condition, i.e., taxa that don't vary too much or too little
#'          within each condition.  `denom = "zero"` will select taxa that are
#'          non-zero within each condition.
#'
gen_aldex_params <- function(lmat, samp, tax_rank, ..., keep_all = FALSE,
                             denom = "all") {
  require(ALDEx2)
  require(reshape2)

  tax_rank <- enquo(tax_rank)
  group_conds <- quos(...)

  # remove samples not in samp from lmat and vice-versa
  kp <- intersect(lmat$sample, samp$sample)
  lmat %<>% filter(sample %in% kp)
  samp %<>% filter(sample %in% kp)

  ## rows are taxa, columns are samples
  lmat_wide <- lmat %>%
    select(sample, !!tax_rank, read_count) %>%
    reshape2::dcast(
      glue("{quo_name(tax_rank)} ~ sample"),
      value.var = 'read_count',
      fill = 0
    ) %>%
    remove_rownames() %>%
    column_to_rownames(quo_name(tax_rank))

  # conds only matters for denom = "iqlr" or "zero"
  if (...length() > 0) {
    conds <- samp %>%
      transmute(sample, cond = paste0(!!!group_conds)) %>%
      deframe()
    conds <- conds[colnames(lmat_wide)]
  } else {
    conds <- rep("allsamples", ncol(lmat_wide))
  }
  if (keep_all) {
    # prevents dropping of study-wide 0s by adding a sample w/ 1 ct per taxon
    lmat_wide %<>% mutate(dummy = 1)
    conds <- c(conds, "dummy" = "dummy")
  }

  # ***ALDEx2 CHANGES SOME SAMPLE NAMES ("-" to ".")***
  original_samplenames <- colnames(lmat_wide) %>% setNames(make.names(.))
  aldex_params <- list(
    reads = lmat_wide,
    conds = conds,
    denom = denom,
    tax_rank = quo_name(tax_rank),
    original_samplenames = original_samplenames,
    keep_all = keep_all
  )
  aldex_params
}

#' Converts an ALDEx2 clr object to long-form tibble
#'
#' @param mc aldex.clr output, contains a list of Monte Carlo instances.
#'           Each list element is a sample, and contains a matrix with rows =
#'           taxa, cols = MC instance.  Note: list is not in the original
#'           sample order
#'
#' @param aldex_params list of params generated by `gen_aldex_params`
#'
#' Taxon proportions are drawn many times (default 128) per sample, then clr
#' transformed using the the features selected within each condition (`denom`)
#' I take the mean as a point estimate and reshape into a long-form tibble with
#' columns `sample`, aldex_params$tax_rank, glue("clr_{aldex_params$denom}")
melt_aldexclr <- function(mc, aldex_params){
  require(ALDEx2)

  tax_rank <- sym(aldex_params$tax_rank)  # What have I become?

  mclst <- getMonteCarloInstances(mc)  # has modified sample names
  names(mclst) <- aldex_params$original_samplenames[names(mclst)]  # restore

  clr_wide <- mclst %>%
    imap(~{
      rowMeans(.x) %>%
      enframe(name = quo_name(tax_rank), value = .y)
    }) %>%
    reduce(inner_join, by = quo_name(tax_rank))

  if (aldex_params$keep_all) {
    clr_wide %<>% select(-one_of("dummy"))
  }

  if (!is.null(aldex_params$denom)) {
    clr_denom <- glue("clr_{aldex_params$denom}")
  } else {
    clr_denom <- "clr"
  }

  clr_long <- clr_wide %>%
    gather(sample, !!sym(clr_denom), -!!tax_rank) %>%
    select(sample, !!tax_rank, !!sym(clr_denom))
  clr_long
}

#' Transform counts in an LMAT tibble with aldex.clr
#'
#' @param lmat tibble of read counts per taxon per sample
#' @param samp tibble with sample metadata
#' @param tax_rank genus, species, etc... as a bare word
#' @param keep_all add dummy uniform sample to keep all taxa
#' @param save_attr saves aldex montecarlo object and aldex.clr params as
#'        attributes
#' @param ... sample grouping variables as bare names
#' @param denom which taxa to use in calculating means
#' @param useMC tell ALDEx2 to "use multicore"
#'
#' Returns a tibble with columns: "sample", quo_name(tax_rank), glue("clr_{denom}")
clrtransform_lmat <- function(lmat, samp, ..., tax_rank, keep_all = FALSE,
                              save_attr = FALSE, denom = "all", useMC = TRUE) {
  require(ALDEx2)

  tax_rank <- enquo(tax_rank)

  aldex_params <- gen_aldex_params(
    lmat = lmat, samp = samp, tax_rank = !!tax_rank, ...,
    denom = denom, keep_all = keep_all
  )

  montecarlo <- aldex.clr(
    reads = aldex_params$reads,
    conds = aldex_params$conds,
    denom = aldex_params$denom,
    useMC = useMC
  )
  clr_long <- melt_aldexclr(montecarlo, aldex_params)
  if(save_attr){
    attributes(clr_long)$params <- aldex_params
    attributes(clr_long)$mc <- montecarlo
  }
  clr_long
}

#' Subset an ALDEx2 MonteCarlo object
#'
#' @param mc a montecarlo object from aldex.clr
#' @param keep_conds named vector of conditions, names are sample names
#' @param ninstances number of montecarlo instances to keep
#'
#' For comparing only a subset of samples to each other
#' using the first ninstances montecarlo instances.
#'
#' ALDEx2 montecarlo slots:
#'   - @reads: data.frame with taxa as rows, samples as columns
#'   - @mc.samples: number of montecarlo instances
#'   - @verbose: logical
#'   - @analysisData: list of matrices for each sample
#'        - length: ncol(@reads)
#'        - each matrix: montecarlo instance with taxa as rows and
#'                       @mc.samples columns
#'   - @conds: character vector grouping samples by condition
#'   - @denom: list of numeric vectors indicating which taxa were used
#'             to calculate the mean for each condition
#'   - @useMC: logical, use multiple cores?
subset_mc <- function(mc, keep_conds, ninstances = mc@mc.samples){
  mangled_samplenames <- make.names(names(keep_conds))
  keep_conds <- as.character(keep_conds)  # enforce class and drop names
  mc@reads <- mc@reads[, mangled_samplenames]
  mc@mc.samples <- ninstances
  mc@analysisData <- mc@analysisData[mangled_samplenames] %>%
    map(~.x[, 1:ninstances])
  mc@conds <- keep_conds
  mc
}
